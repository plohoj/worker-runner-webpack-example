{"version":3,"sources":["webpack:///./node_modules/@worker-runner/core/esm/core.js","webpack:///./node_modules/@worker-runner/promise/esm/promise.js","webpack:///./src/scripts/common.ts","webpack:///./src/scripts/library-runner.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAiF;;AAEjF;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;;AAEvD;AACA,qCAAqC;AACrC,mDAAmD,kBAAkB;AACrE,qCAAqC,WAAW;AAChD,KAAK;AACL,uCAAuC;AACvC,mDAAmD,kBAAkB;AACrE,6BAA6B,WAAW;AACxC,KAAK;AACL,iCAAiC;AACjC,oDAAoD,kBAAkB;AACtE,6DAA6D,WAAW;AACxE,KAAK;AACL,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA,gCAAgC,iBAAiB;AACjD,KAAK;AACL;AACA;AACA,KAAK;AACL,gCAAgC;AAChC,yDAAyD,kBAAkB;AAC3E,kCAAkC,WAAW;AAC7C,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+BAA+B;AAClF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,+DAA+D,gBAAgB,EAAE,EAAE;AAC9G;AACA,mCAAmC,MAAM,6BAA6B,EAAE,YAAY,WAAW,EAAE;AACjG,kCAAkC,MAAM,iCAAiC,EAAE,YAAY,WAAW,EAAE;AACpG,+BAA+B,qFAAqF;AACpH;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,SAAS,EAAE;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uEAAuE,2BAA2B;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,8BAA8B;AACjH,iBAAiB;AACjB;AACA;AACA;AACA,mFAAmF,8BAA8B;AACjH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6EAA6E,0BAA0B;AACvG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wBAAwB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB,SAAS;AACT;AACA;AACA,qFAAqF,wBAAwB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,qBAAqB;AACrB,qCAAqC,OAAO,sEAAoB,iBAAiB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6DAA6D;AAC1H;AACA;AACA,oFAAoF,8BAA8B;AAClH;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,6DAA6D;AAC1H;AACA;AACA,oFAAoF,8BAA8B;AAClH;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,6DAA6D;AAClH;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6DAA6D;AACtH;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,6DAA6D;AACnH;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,6DAA6D;AACvH;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2CAA2C;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8DAA8D;AACrH;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,uCAAuC;AAChF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8DAA8D;AACjH;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEmhB;AACnhB;;;;;;;;;;;;;AC3qCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA+F;;AAE/F,iCAAiC,kFAA8B;AAC/D;;AAEA,mCAAmC,4EAAwB;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyF;AACzF;;;;;;;;;;;;;;;;AC1BA,0HAAwD;AACxD,sGAAiD;AAEpC,sBAAc,GAAG,IAAI,wBAAc,CAAC;IAC7C,OAAO,EAAE,CAAC,8BAAa,CAAC;IACxB,UAAU,EAAE,oBAAoB;CACnC,CAAC,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNH,IAAM,gBAAgB,GAAG,4EAA4E,CAAC;AACtG,IAAM,cAAc,GAAG,oBAAoB,CAAC;AAC5C,IAAM,iBAAiB,GAAG,cAAc,CAAC;AAEzC;IAEI,uBAAa,KAAoB;QAApB,kCAAoB;QAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,CAAC;IAEM,+BAAO,GAAd,UAAe,IAAY;QACvB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACtB,OAAO,CAAC,GAAG,CACP,0BAAuB,IAAI,0BAAsB,EACjD,gBAAgB,EAAE,EAAE,EAAE,cAAc,EAAE,EAAE,CAC3C,CAAC;IACN,CAAC;IAEM,iCAAS,GAAhB,UAAiB,IAAY;QACzB,IAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;QAChD,OAAO,CAAC,GAAG,CACP,0BAAuB,IAAI,mCAA+B,EAC1D,gBAAgB,EAAE,EAAE,EAAE,cAAc,EAAE,EAAE,EAAE,OAAO,CACpD,CAAC;QACF,OAAO,OAAO,CAAC;IACnB,CAAC;IAEY,mCAAW,GAAxB,UAAyB,IAAY,EAAE,OAAe;;;;;wBAClD,OAAO,CAAC,GAAG,CACP,0BAAuB,IAAI,4BAAsB,OAAO,eAAY,EACpE,gBAAgB,EAAE,EAAE,EAAE,cAAc,EAAE,EAAE,EAAE,iBAAiB,EAAE,EAAE,CAClE,CAAC;wBAEF,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,qBAAW,IAAI,kBAAW,KAAK,IAAI,EAApB,CAAoB,CAAC,CAAC;wBAEpE,qBAAM,IAAI,OAAO,CAAC,iBAAO,IAAI,iBAAU,CAAC,cAAM,cAAO,EAAE,EAAT,CAAS,EAAE,OAAO,GAAG,IAAI,CAAC,EAA3C,CAA2C,CAAC;;wBAAzE,SAAyE,CAAC;wBAC1E,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;wBAEtB,OAAO,CAAC,GAAG,CACP,0CAAuC,IAAI,+BAAyB,OAAO,eAAY,EACvF,gBAAgB,EAAE,EAAE,EAAE,cAAc,EAAE,EAAE,EAAE,iBAAiB,EAAE,EAAE,CAClE,CAAC;wBACF,sBAAO,IAAI,EAAC;;;;KACf;IACL,oBAAC;AAAD,CAAC;AAxCY,sCAAa","file":"commons.js","sourcesContent":["import { NodeResolverAction as NodeResolverAction$1 } from '@worker-runner/core';\n\nvar NodeResolverAction;\r\n(function (NodeResolverAction) {\r\n    NodeResolverAction[NodeResolverAction[\"INIT_RUNNER\"] = 0] = \"INIT_RUNNER\";\r\n    NodeResolverAction[NodeResolverAction[\"DESTROY\"] = 1] = \"DESTROY\";\r\n})(NodeResolverAction || (NodeResolverAction = {}));\n\nvar RunnerControllerAction;\r\n(function (RunnerControllerAction) {\r\n    RunnerControllerAction[RunnerControllerAction[\"EXECUTE\"] = 10] = \"EXECUTE\";\r\n    RunnerControllerAction[RunnerControllerAction[\"DISCONNECT\"] = 11] = \"DISCONNECT\";\r\n    RunnerControllerAction[RunnerControllerAction[\"DESTROY\"] = 12] = \"DESTROY\";\r\n    RunnerControllerAction[RunnerControllerAction[\"RESOLVE\"] = 13] = \"RESOLVE\";\r\n})(RunnerControllerAction || (RunnerControllerAction = {}));\n\nvar RunnerEnvironmentAction;\r\n(function (RunnerEnvironmentAction) {\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"EXECUTED\"] = 10] = \"EXECUTED\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"EXECUTED_WITH_RUNNER_RESULT\"] = 11] = \"EXECUTED_WITH_RUNNER_RESULT\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"DISCONNECTED\"] = 12] = \"DISCONNECTED\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"DESTROYED\"] = 13] = \"DESTROYED\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"EXECUTE_ERROR\"] = 14] = \"EXECUTE_ERROR\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"DESTROY_ERROR\"] = 15] = \"DESTROY_ERROR\";\r\n    RunnerEnvironmentAction[RunnerEnvironmentAction[\"RESOLVED\"] = 16] = \"RESOLVED\";\r\n})(RunnerEnvironmentAction || (RunnerEnvironmentAction = {}));\n\nvar WorkerResolverAction;\r\n(function (WorkerResolverAction) {\r\n    WorkerResolverAction[WorkerResolverAction[\"WORKER_INITED\"] = 0] = \"WORKER_INITED\";\r\n    WorkerResolverAction[WorkerResolverAction[\"RUNNER_INITED\"] = 1] = \"RUNNER_INITED\";\r\n    WorkerResolverAction[WorkerResolverAction[\"RUNNER_INIT_ERROR\"] = 2] = \"RUNNER_INIT_ERROR\";\r\n    WorkerResolverAction[WorkerResolverAction[\"DESTROYED\"] = 3] = \"DESTROYED\";\r\n})(WorkerResolverAction || (WorkerResolverAction = {}));\n\nvar WorkerRunnerErrorCode;\r\n(function (WorkerRunnerErrorCode) {\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"RUNNER_INIT_ERROR\"] = 0] = \"RUNNER_INIT_ERROR\";\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"RUNNER_EXECUTE_ERROR\"] = 1] = \"RUNNER_EXECUTE_ERROR\";\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"RUNNER_DESTROY_ERROR\"] = 2] = \"RUNNER_DESTROY_ERROR\";\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"RUNNER_NOT_INIT\"] = 3] = \"RUNNER_NOT_INIT\";\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"WORKER_NOT_INIT\"] = 4] = \"WORKER_NOT_INIT\";\r\n    WorkerRunnerErrorCode[WorkerRunnerErrorCode[\"UNEXPECTED_ERROR\"] = 5] = \"UNEXPECTED_ERROR\";\r\n})(WorkerRunnerErrorCode || (WorkerRunnerErrorCode = {}));\n\nconst WORKER_RUNNER_ERROR_MESSAGES = {\r\n    CONSTRUCTOR_NOT_FOUND(config = {}) {\r\n        const runnerName = config.runnerName ? `<${config.runnerName}> ` : '';\r\n        return `Runner constructor ${runnerName}not found`;\r\n    },\r\n    RUNNER_WAS_DISCONNECTED(config = {}) {\r\n        const runnerName = config.runnerName ? `<${config.runnerName}> ` : '';\r\n        return `The Runner ${runnerName}was destroyed or disconnected`;\r\n    },\r\n    RUNNER_INIT_ERROR(config = {}) {\r\n        const runnerName = config.runnerName ? ` <${config.runnerName}>` : '';\r\n        return `An error occurred while initializing Runner${runnerName}`;\r\n    },\r\n    EXECUTE_ERROR(config = {}) {\r\n        const methodInfo = new Array();\r\n        if (config.runnerName) {\r\n            methodInfo.push(config.runnerName);\r\n        }\r\n        if (config.methodName) {\r\n            methodInfo.push(config.methodName + '(...)');\r\n        }\r\n        let methodInfoString = methodInfo.join('.');\r\n        if (methodInfoString) {\r\n            methodInfoString = ` <${methodInfoString}>`;\r\n        }\r\n        return `Runtime Error ${methodInfoString}`;\r\n    },\r\n    WORKER_NOT_INIT() {\r\n        return 'Worker not init';\r\n    },\r\n    UNEXPECTED_ERROR(config = {}) {\r\n        const runnerName = config.runnerName ? ` with <${config.runnerName}>` : '';\r\n        return `Unexpected Error${runnerName}`;\r\n    },\r\n    WORKER_DESTROYED_WITHOUT_CALL() {\r\n        return 'An action was received about the successful destroy,'\r\n            + ' but the destroy method was not previously called';\r\n    },\r\n};\n\nvar _a;\r\nconst WORKER_RUNNER_ERROR_CODE = Symbol('Worker Runner error code');\r\nclass WorkerRunnerError extends Error {\r\n    constructor(config = {}) {\r\n        super(config.message);\r\n        if (config.stack) {\r\n            this.stack = config.stack;\r\n        }\r\n        else if (Error.captureStackTrace) {\r\n            if (config.captureOpt) {\r\n                Error.captureStackTrace(this, config.captureOpt);\r\n            }\r\n            Error.captureStackTrace(WorkerRunnerError);\r\n        }\r\n        this.name = config.name || WorkerRunnerError.name;\r\n    }\r\n}\r\nclass WorkerRunnerUnexpectedError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || WorkerRunnerUnexpectedError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || WorkerRunnerUnexpectedError,\r\n        });\r\n        this[_a] = WorkerRunnerErrorCode.UNEXPECTED_ERROR;\r\n    }\r\n}\r\n_a = WORKER_RUNNER_ERROR_CODE;\n\nvar _a$1, _b, _c, _d, _e;\r\nclass RunnerInitError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || RunnerInitError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.CONSTRUCTOR_NOT_FOUND(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || RunnerInitError,\r\n        });\r\n        this[_a$1] = WorkerRunnerErrorCode.RUNNER_INIT_ERROR;\r\n    }\r\n}\r\n_a$1 = WORKER_RUNNER_ERROR_CODE;\r\nclass RunnerWasDisconnectedError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || RunnerWasDisconnectedError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || RunnerWasDisconnectedError,\r\n        });\r\n        this[_b] = WorkerRunnerErrorCode.RUNNER_NOT_INIT;\r\n    }\r\n}\r\n_b = WORKER_RUNNER_ERROR_CODE;\r\nclass RunnerExecuteError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || RunnerExecuteError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.EXECUTE_ERROR(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || RunnerExecuteError,\r\n        });\r\n        this[_c] = WorkerRunnerErrorCode.RUNNER_EXECUTE_ERROR;\r\n    }\r\n}\r\n_c = WORKER_RUNNER_ERROR_CODE;\r\nclass RunnerDestroyError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || RunnerDestroyError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || RunnerDestroyError,\r\n        });\r\n        this[_d] = WorkerRunnerErrorCode.RUNNER_DESTROY_ERROR;\r\n    }\r\n}\r\n_d = WORKER_RUNNER_ERROR_CODE;\r\nclass WorkerNotInitError extends WorkerRunnerError {\r\n    constructor(config = {}) {\r\n        super({\r\n            name: config.name || WorkerNotInitError.name,\r\n            message: config.message || WORKER_RUNNER_ERROR_MESSAGES.WORKER_NOT_INIT(),\r\n            stack: config.stack,\r\n            captureOpt: config.captureOpt || WorkerNotInitError,\r\n        });\r\n        this[_e] = WorkerRunnerErrorCode.RUNNER_NOT_INIT;\r\n    }\r\n}\r\n_e = WORKER_RUNNER_ERROR_CODE;\n\nconst CODE_TO_ERROR_MAP = {\r\n    [WorkerRunnerErrorCode.RUNNER_INIT_ERROR]: RunnerInitError,\r\n    [WorkerRunnerErrorCode.RUNNER_EXECUTE_ERROR]: RunnerExecuteError,\r\n    [WorkerRunnerErrorCode.RUNNER_DESTROY_ERROR]: RunnerDestroyError,\r\n    [WorkerRunnerErrorCode.RUNNER_NOT_INIT]: RunnerWasDisconnectedError,\r\n    [WorkerRunnerErrorCode.WORKER_NOT_INIT]: WorkerNotInitError,\r\n    [WorkerRunnerErrorCode.UNEXPECTED_ERROR]: WorkerRunnerUnexpectedError,\r\n};\n\nclass WorkerRunnerErrorSerializer {\r\n    constructor() {\r\n        this.codeToErrorMap = CODE_TO_ERROR_MAP;\r\n    }\r\n    serialize(error = {}, alternativeError = {}) {\r\n        if (error instanceof Error) {\r\n            let errorCode = error[WORKER_RUNNER_ERROR_CODE];\r\n            if (typeof errorCode !== 'number') {\r\n                errorCode = alternativeError.errorCode;\r\n                if (typeof errorCode !== 'number') {\r\n                    errorCode = WorkerRunnerErrorCode.UNEXPECTED_ERROR;\r\n                }\r\n            }\r\n            return {\r\n                errorCode,\r\n                name: error.name || alternativeError.name || WorkerRunnerUnexpectedError.name,\r\n                message: error.message || alternativeError.message || WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR(),\r\n                stack: error.stack || alternativeError.stack,\r\n            };\r\n        }\r\n        return {\r\n            errorCode: typeof alternativeError.errorCode === 'number' ?\r\n                alternativeError.errorCode : WorkerRunnerErrorCode.UNEXPECTED_ERROR,\r\n            name: alternativeError.name || WorkerRunnerUnexpectedError.name,\r\n            message: error ? String(error) : (alternativeError.message\r\n                || WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR()),\r\n            stack: alternativeError.stack,\r\n        };\r\n    }\r\n    deserialize(error) {\r\n        let errorConstructor = this.codeToErrorMap[error.errorCode];\r\n        if (!errorConstructor) {\r\n            errorConstructor = WorkerRunnerUnexpectedError;\r\n        }\r\n        return new errorConstructor(Object.assign({ captureOpt: this.deserialize }, error));\r\n    }\r\n}\r\nconst WORKER_RUNNER_ERROR_SERIALIZER = new WorkerRunnerErrorSerializer();\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nconst EXECUTE_RUNNER_BRIDGE_METHOD = Symbol('Execute RunnerBridge method');\r\nconst RUNNER_BRIDGE_CONTROLLER = Symbol('Execute via NodeResolver method');\r\nclass RunnerBridge {\r\n    constructor(controller) {\r\n        this[RUNNER_BRIDGE_CONTROLLER] = controller;\r\n    }\r\n    static isRunnerBridge(instance) {\r\n        return !!instance && !!instance[RUNNER_BRIDGE_CONTROLLER];\r\n    }\r\n    [EXECUTE_RUNNER_BRIDGE_METHOD](methodName, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this[RUNNER_BRIDGE_CONTROLLER].execute(methodName, args);\r\n        });\r\n    }\r\n    /** Unsubscribe from runner, if the control object was the last, then runner will be automatically destroyed */\r\n    disconnect() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this[RUNNER_BRIDGE_CONTROLLER].disconnect();\r\n        });\r\n    }\r\n    /** Destroying and remove Runner instance from resolved Runners list in `RunnerResolver` instance */\r\n    destroy() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this[RUNNER_BRIDGE_CONTROLLER].destroy();\r\n        });\r\n    }\r\n    /** Returns a new control object for the same Runner instance */\r\n    cloneControl() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const runnerController = yield this[RUNNER_BRIDGE_CONTROLLER].cloneControl();\r\n            return runnerController.resolvedRunner;\r\n        });\r\n    }\r\n    /**\r\n     * When a Runner is flagged for transfer, if it is used as argument or as method result,\r\n     * the original control will be transferred. The original Resolved Runner will lose control.\r\n     * In this case, the transfer of the Resolved Runner will be faster\r\n     * because it will not take time to request a copy of the control.\r\n     * It is convenient to use as an automatic disconnect after returning the result of a method.\r\n     */\r\n    markForTransfer() {\r\n        this[RUNNER_BRIDGE_CONTROLLER].markForTransfer();\r\n        return this;\r\n    }\r\n}\n\nfunction recursiveOverrideProperty(construct, proto) {\r\n    for (const key of Object.getOwnPropertyNames(proto.prototype)) {\r\n        if (!(key in RunnerBridge.prototype)) {\r\n            construct.prototype[key] = function (...args) {\r\n                return this[EXECUTE_RUNNER_BRIDGE_METHOD](key, args);\r\n            };\r\n        }\r\n        const parent = Object.getPrototypeOf(proto);\r\n        if (parent.prototype) {\r\n            recursiveOverrideProperty(construct, parent);\r\n        }\r\n    }\r\n}\r\nfunction resolveRunnerBridgeConstructor(runner) {\r\n    const className = 'Resolved' + runner.name;\r\n    const ResolvedRunner = { [className]: class extends RunnerBridge {\r\n        } }[className];\r\n    recursiveOverrideProperty(ResolvedRunner, runner);\r\n    return ResolvedRunner;\r\n}\n\nclass PromisesResolver {\r\n    constructor() {\r\n        this.promises = new Map();\r\n    }\r\n    promise(id) {\r\n        return new Promise((resolve, reject) => this.promises.set(id, { resolve: resolve, reject }));\r\n    }\r\n    resolve(id, data) {\r\n        const promise$ = this.promises.get(id);\r\n        if (promise$) {\r\n            this.promises.delete(id);\r\n            promise$.resolve(data);\r\n        }\r\n    }\r\n    reject(id, error) {\r\n        const promise$ = this.promises.get(id);\r\n        if (promise$) {\r\n            this.promises.delete(id);\r\n            promise$.reject(error);\r\n        }\r\n    }\r\n    forget(id) {\r\n        const promise$ = this.promises.get(id);\r\n        this.promises.delete(id);\r\n        return promise$;\r\n    }\r\n}\n\nclass RunnerController {\r\n    constructor(config) {\r\n        this.isMarkedForTransfer = false;\r\n        this.promises = new PromisesResolver();\r\n        this.lastActionId = 0;\r\n        this.errorSerializer = WORKER_RUNNER_ERROR_SERIALIZER;\r\n        const bridgeConstructor = config.runnerBridgeConstructors[config.runnerId];\r\n        if (!bridgeConstructor) {\r\n            throw new RunnerInitError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n            });\r\n        }\r\n        this.resolvedRunner = new bridgeConstructor(this);\r\n        this.runnerId = config.runnerId;\r\n        this.port = config.port;\r\n        this.port.onmessage = this.onPortMessage.bind(this);\r\n        this.onDisconnected = config.onDisconnected;\r\n        this.runnerBridgeConstructors = config.runnerBridgeConstructors;\r\n        this.runners = config.runners;\r\n    }\r\n    onPortMessage(message) {\r\n        this.handleAction(message.data);\r\n    }\r\n    nextActionId() {\r\n        return this.lastActionId++;\r\n    }\r\n    execute(methodName, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const actionId = this.nextActionId();\r\n            const executePromise$ = this.promises\r\n                .promise(actionId);\r\n            let serializedArgumentsData;\r\n            try {\r\n                serializedArgumentsData = yield NodeRunnerResolverBase.serializeArguments(args);\r\n            }\r\n            catch (error) {\r\n                this.promises.forget(actionId);\r\n                throw error;\r\n            }\r\n            this.sendAction({\r\n                type: RunnerControllerAction.EXECUTE,\r\n                id: actionId,\r\n                args: serializedArgumentsData.args,\r\n                method: methodName,\r\n            }, serializedArgumentsData.transfer);\r\n            const actionResult = yield executePromise$;\r\n            if (actionResult.type === RunnerEnvironmentAction.EXECUTED_WITH_RUNNER_RESULT) {\r\n                return this.buildControlClone(actionResult.runnerId, actionResult.port).resolvedRunner;\r\n            }\r\n            return actionResult.response;\r\n        });\r\n    }\r\n    disconnect() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const actionId = this.nextActionId();\r\n            const disconnectPromise$ = this.promises.promise(actionId);\r\n            this.sendAction({\r\n                type: RunnerControllerAction.DISCONNECT,\r\n                id: actionId,\r\n            });\r\n            yield disconnectPromise$;\r\n            this.onDisconnect();\r\n        });\r\n    }\r\n    destroy() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const actionId = this.nextActionId();\r\n            const destroyPromise$ = this.promises.promise(actionId);\r\n            this.sendAction({\r\n                type: RunnerControllerAction.DESTROY,\r\n                id: actionId,\r\n            });\r\n            yield destroyPromise$;\r\n        });\r\n    }\r\n    buildControlClone(runnerId, port) {\r\n        return new this.constructor({\r\n            runnerId,\r\n            runnerBridgeConstructors: this.runnerBridgeConstructors,\r\n            port,\r\n            runners: this.runners,\r\n        });\r\n    }\r\n    get runnerName() {\r\n        return this.runners[this.runnerId].name;\r\n    }\r\n    cloneControl() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.buildControlClone(this.runnerId, yield this.resolveControl());\r\n        });\r\n    }\r\n    transferControl() {\r\n        if (!this.port) {\r\n            throw new RunnerWasDisconnectedError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n            });\r\n        }\r\n        const port = this.port;\r\n        this.onDisconnect(false);\r\n        return port;\r\n    }\r\n    markForTransfer() {\r\n        if (!this.port) {\r\n            throw new RunnerWasDisconnectedError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n            });\r\n        }\r\n        this.isMarkedForTransfer = true;\r\n    }\r\n    resolveControl() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const actionId = this.nextActionId();\r\n            const promise$ = this.promises.promise(actionId);\r\n            this.sendAction({\r\n                type: RunnerControllerAction.RESOLVE,\r\n                id: actionId,\r\n            });\r\n            return (yield promise$).port;\r\n        });\r\n    }\r\n    resolveOrTransferControl() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.isMarkedForTransfer) {\r\n                return this.transferControl();\r\n            }\r\n            return this.resolveControl();\r\n        });\r\n    }\r\n    handleAction(action) {\r\n        switch (action.type) {\r\n            case RunnerEnvironmentAction.DISCONNECTED:\r\n            case RunnerEnvironmentAction.EXECUTED:\r\n            case RunnerEnvironmentAction.EXECUTED_WITH_RUNNER_RESULT:\r\n            case RunnerEnvironmentAction.RESOLVED:\r\n                this.promises.resolve(action.id, action);\r\n                break;\r\n            case RunnerEnvironmentAction.DESTROYED:\r\n                const resolvedPromise = this.promises.forget(action.id);\r\n                this.onDisconnect();\r\n                resolvedPromise === null || resolvedPromise === void 0 ? void 0 : resolvedPromise.resolve(action);\r\n                break;\r\n            case RunnerEnvironmentAction.EXECUTE_ERROR:\r\n                this.promises.reject(action.id, this.errorSerializer.deserialize(action));\r\n                break;\r\n            case RunnerEnvironmentAction.DESTROY_ERROR:\r\n                const rejectedPromise = this.promises.forget(action.id);\r\n                this.onDisconnect();\r\n                rejectedPromise === null || rejectedPromise === void 0 ? void 0 : rejectedPromise.reject(this.errorSerializer.deserialize(action));\r\n                break;\r\n        }\r\n    }\r\n    sendAction(action, transfer) {\r\n        if (!this.port) {\r\n            if (action.type === RunnerControllerAction.EXECUTE) {\r\n                throw new RunnerExecuteError({\r\n                    message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n                });\r\n            }\r\n            else {\r\n                throw new RunnerWasDisconnectedError({\r\n                    message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n                });\r\n            }\r\n        }\r\n        this.port.postMessage(action, transfer);\r\n    }\r\n    onDisconnect(closePort = true) {\r\n        var _a;\r\n        this.promises.promises.forEach(promise => {\r\n            promise.reject(new RunnerWasDisconnectedError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n            }));\r\n        });\r\n        this.promises.promises.clear();\r\n        if (!this.port) {\r\n            throw new RunnerWasDisconnectedError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_WAS_DISCONNECTED({ runnerName: this.runnerName }),\r\n            });\r\n        }\r\n        if (closePort) {\r\n            this.port.close();\r\n        }\r\n        this.port.onmessage = null;\r\n        this.port = undefined;\r\n        (_a = this.onDisconnected) === null || _a === void 0 ? void 0 : _a.call(this);\r\n    }\r\n}\n\nvar RunnerArgumentType;\r\n(function (RunnerArgumentType) {\r\n    RunnerArgumentType[RunnerArgumentType[\"JSON\"] = 0] = \"JSON\";\r\n    RunnerArgumentType[RunnerArgumentType[\"RUNNER_INSTANCE\"] = 1] = \"RUNNER_INSTANCE\";\r\n})(RunnerArgumentType || (RunnerArgumentType = {}));\n\n/** Allows you to use `Transferable` data as argument or a method result. */\r\nclass TransferRunnerData {\r\n    constructor(data, transfer) {\r\n        this.data = data;\r\n        this.transfer = transfer;\r\n    }\r\n}\n\nconst DEFAULT_RUNNER_RESOLVER_BASE_CONFIG = {\r\n    workerName: 'Worker Runner',\r\n    runners: [],\r\n    workerPath: 'worker.js',\r\n};\r\nclass NodeRunnerResolverBase {\r\n    constructor(config) {\r\n        this.initPromises = new PromisesResolver();\r\n        this.lastActionId = 0;\r\n        this.workerMessageHandler = this.onWorkerMessage.bind(this);\r\n        this.RunnerControllerConstructor = RunnerController;\r\n        this.errorSerializer = WORKER_RUNNER_ERROR_SERIALIZER;\r\n        this.runnerControllers = new Set();\r\n        this.runnerBridgeConstructors = new Array();\r\n        this.runners = config.runners || DEFAULT_RUNNER_RESOLVER_BASE_CONFIG.runners;\r\n        this.workerName = config.workerPath || DEFAULT_RUNNER_RESOLVER_BASE_CONFIG.workerName;\r\n        this.workerPath = config.workerPath || DEFAULT_RUNNER_RESOLVER_BASE_CONFIG.workerPath;\r\n    }\r\n    static serializeArguments(args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const serializedArgs = {\r\n                args: new Array(),\r\n                transfer: new Array(),\r\n            };\r\n            const argsMap = new Map();\r\n            yield Promise.all(args.map((argumentWithTransferData, index) => __awaiter(this, void 0, void 0, function* () {\r\n                let argument;\r\n                if (argumentWithTransferData instanceof TransferRunnerData) {\r\n                    serializedArgs.transfer.push(...argumentWithTransferData.transfer);\r\n                    argument = argumentWithTransferData.data;\r\n                }\r\n                else {\r\n                    argument = argumentWithTransferData;\r\n                }\r\n                if (RunnerBridge.isRunnerBridge(argument)) {\r\n                    const controller = argument[RUNNER_BRIDGE_CONTROLLER];\r\n                    const transferPort = yield controller.resolveOrTransferControl();\r\n                    argsMap.set(index, {\r\n                        type: RunnerArgumentType.RUNNER_INSTANCE,\r\n                        port: transferPort,\r\n                        runnerId: controller.runnerId,\r\n                    });\r\n                    serializedArgs.transfer.push(transferPort);\r\n                }\r\n                else {\r\n                    argsMap.set(index, {\r\n                        type: RunnerArgumentType.JSON,\r\n                        data: argument,\r\n                    });\r\n                }\r\n            })));\r\n            for (let i = 0; i < args.length; i++) {\r\n                serializedArgs.args.push(argsMap.get(i));\r\n            }\r\n            return serializedArgs;\r\n        });\r\n    }\r\n    /** Launches and prepares RunnerResolver for work */\r\n    run() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.runnerBridgeConstructors = this.runners.map(runner => resolveRunnerBridgeConstructor(runner));\r\n            yield this.initWorker();\r\n        });\r\n    }\r\n    /** Returns a runner control object that will call the methods of the source instance */\r\n    resolve(runner, ...args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const runnerId = this.getRunnerId(runner);\r\n            const action = yield this.sendInitAction(runnerId, args);\r\n            return this.buildRunnerController(runnerId, action.port).resolvedRunner;\r\n        });\r\n    }\r\n    getRunnerId(runner) {\r\n        const runnerId = this.runners.indexOf(runner);\r\n        if (runnerId < 0) {\r\n            throw new RunnerInitError({\r\n                message: WORKER_RUNNER_ERROR_MESSAGES.CONSTRUCTOR_NOT_FOUND({ runnerName: runner.name }),\r\n            });\r\n        }\r\n        return runnerId;\r\n    }\r\n    buildRunnerController(runnerId, port) {\r\n        const runnerController = new this.RunnerControllerConstructor({\r\n            onDisconnected: () => this.runnerControllers.delete(runnerController),\r\n            port,\r\n            runnerBridgeConstructors: this.runnerBridgeConstructors,\r\n            runnerId,\r\n            runners: this.runners,\r\n        });\r\n        this.runnerControllers.add(runnerController);\r\n        return runnerController;\r\n    }\r\n    sendInitAction(runnerId, args) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const actionId = this.nextActionId();\r\n                const promise$ = this.initPromises.promise(actionId);\r\n                const serializedArgs = yield NodeRunnerResolverBase.serializeArguments(args);\r\n                this.sendAction({\r\n                    type: NodeResolverAction.INIT_RUNNER,\r\n                    id: actionId,\r\n                    runnerId,\r\n                    args: serializedArgs.args,\r\n                }, serializedArgs.transfer);\r\n                return yield promise$;\r\n            }\r\n            catch (error) {\r\n                if (error instanceof WorkerRunnerError) {\r\n                    throw error;\r\n                }\r\n                throw new RunnerInitError(this.errorSerializer.serialize(error, {\r\n                    message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_INIT_ERROR({\r\n                        runnerName: this.runners[runnerId].name,\r\n                    }),\r\n                }));\r\n            }\r\n        });\r\n    }\r\n    nextActionId() {\r\n        return this.lastActionId++;\r\n    }\r\n    onWorkerMessage(message) {\r\n        this.handleWorkerAction(message.data);\r\n    }\r\n    handleWorkerAction(action) {\r\n        switch (action.type) {\r\n            case WorkerResolverAction.RUNNER_INITED:\r\n                this.initPromises.resolve(action.id, action);\r\n                break;\r\n            case WorkerResolverAction.RUNNER_INIT_ERROR:\r\n                this.initPromises.reject(action.id, this.errorSerializer.deserialize(action));\r\n                break;\r\n            case WorkerResolverAction.DESTROYED:\r\n                if (!this.destroyPromise) {\r\n                    throw new WorkerRunnerUnexpectedError({\r\n                        message: WORKER_RUNNER_ERROR_MESSAGES.WORKER_DESTROYED_WITHOUT_CALL(),\r\n                    });\r\n                }\r\n                this.destroyPromise.resolve();\r\n                this.destroyPromise = undefined;\r\n                break;\r\n        }\r\n    }\r\n    initWorker() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const worker = new Worker(this.workerPath, { name: this.workerName });\r\n            yield new Promise(resolve => {\r\n                worker.onmessage = (message) => {\r\n                    if (message.data && message.data.type === WorkerResolverAction.WORKER_INITED) {\r\n                        resolve();\r\n                    }\r\n                };\r\n            });\r\n            this.worker = worker;\r\n            this.worker.addEventListener('message', this.workerMessageHandler);\r\n        });\r\n    }\r\n    destroyRunnerControllers() {\r\n        this.runnerControllers.forEach(state => state.onDisconnect());\r\n        this.runnerControllers.clear();\r\n    }\r\n    /**\r\n     * Destroying of all resolved Runners instance\r\n     * @param force Destroy by skipping the call the destruction method on the remaining instances\r\n     */\r\n    destroy(force = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.worker) {\r\n                const destroyPromise$ = new Promise((resolve, reject) => {\r\n                    this.destroyPromise = { resolve, reject };\r\n                });\r\n                this.sendAction({\r\n                    type: NodeResolverAction.DESTROY,\r\n                    force,\r\n                });\r\n                yield destroyPromise$;\r\n                this.destroyRunnerControllers();\r\n                this.worker.terminate();\r\n                this.worker = undefined;\r\n            }\r\n            else {\r\n                throw new WorkerNotInitError();\r\n            }\r\n        });\r\n    }\r\n    sendAction(action, transfer) {\r\n        if (this.worker) { // TODO use MessageChanel\r\n            this.worker.postMessage(action, transfer);\r\n        }\r\n        else {\r\n            throw new WorkerNotInitError();\r\n        }\r\n    }\r\n}\n\nclass NodeAndLocalRunnerResolverBase extends NodeRunnerResolverBase {\r\n    initWorker() {\r\n        const _super = Object.create(null, {\r\n            initWorker: { get: () => super.initWorker }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.WorkerResolverConstructor) {\r\n                this.localWorkerRunnerResolver = new this.WorkerResolverConstructor({ runners: this.runners });\r\n                this.localMessageChanel = new MessageChannel();\r\n                this.localMessageChanel.port1.onmessage = this.onWorkerMessage.bind(this);\r\n                this.localWorkerRunnerResolver.sendAction\r\n                    = this.localMessageChanel.port2.postMessage.bind(this.localMessageChanel.port2);\r\n                this.localMessageChanel.port2.onmessage\r\n                    = this.localWorkerRunnerResolver.onMessage.bind(this.localWorkerRunnerResolver);\r\n            }\r\n            else {\r\n                return _super.initWorker.call(this);\r\n            }\r\n        });\r\n    }\r\n    destroy(force = false) {\r\n        const _super = Object.create(null, {\r\n            destroy: { get: () => super.destroy }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.WorkerResolverConstructor) {\r\n                if (this.localWorkerRunnerResolver) {\r\n                    const destroyPromise$ = new Promise((resolve, reject) => {\r\n                        this.destroyPromise = { resolve, reject };\r\n                    });\r\n                    this.sendAction({ type: NodeResolverAction$1.DESTROY, force });\r\n                    yield destroyPromise$;\r\n                    this.destroyRunnerControllers();\r\n                    this.localWorkerRunnerResolver.sendAction = undefined;\r\n                    if (this.localMessageChanel) {\r\n                        this.localMessageChanel.port2.onmessage = undefined;\r\n                        this.localMessageChanel.port1.onmessage = undefined;\r\n                        this.localMessageChanel = undefined;\r\n                    }\r\n                    this.localWorkerRunnerResolver = undefined;\r\n                }\r\n                else {\r\n                    throw new WorkerNotInitError();\r\n                }\r\n            }\r\n            else {\r\n                return _super.destroy.call(this, force);\r\n            }\r\n        });\r\n    }\r\n    sendAction(action, transfer) {\r\n        if (this.WorkerResolverConstructor) {\r\n            if (this.localMessageChanel) {\r\n                this.localMessageChanel.port1.postMessage(action, transfer);\r\n            }\r\n            else {\r\n                throw new WorkerNotInitError();\r\n            }\r\n        }\r\n        else {\r\n            super.sendAction(action, transfer);\r\n        }\r\n    }\r\n    /**\r\n     * Wraps the Runner and returns a Runner control object that will call the methods of the original Runner instance.\r\n     * The original Runner instance will be executed in the same area in which it was wrapped.\r\n     */\r\n    wrapRunner(runnerInstance) {\r\n        if (!this.localWorkerRunnerResolver) {\r\n            throw new WorkerNotInitError();\r\n        }\r\n        const runnerId = this.getRunnerId(Object.getPrototypeOf(runnerInstance).constructor);\r\n        const port = this.localWorkerRunnerResolver.wrapRunner(runnerInstance);\r\n        const controller = this.buildRunnerController(runnerId, port);\r\n        return controller.resolvedRunner;\r\n    }\r\n}\n\nclass RunnerEnvironment {\r\n    constructor(config) {\r\n        this.ports = new Array();\r\n        this.connectedControllers = new Array();\r\n        this.errorSerializer = WORKER_RUNNER_ERROR_SERIALIZER;\r\n        this.runnerInstance = config.runner;\r\n        this.workerRunnerResolver = config.workerRunnerResolver;\r\n        this.ports.push(config.port);\r\n        config.port.onmessage = this.onPortMessage.bind(this, config.port);\r\n        this.onDestroyed = config.onDestroyed;\r\n    }\r\n    onPortMessage(port, message) {\r\n        this.handleAction(port, message.data);\r\n    }\r\n    get runnerName() {\r\n        return this.runnerInstance.constructor.name;\r\n    }\r\n    handleAction(port, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            switch (action.type) {\r\n                case RunnerControllerAction.EXECUTE:\r\n                    try {\r\n                        yield this.execute(port, action);\r\n                    }\r\n                    catch (error) {\r\n                        this.sendAction(port, Object.assign({ id: action.id, type: RunnerEnvironmentAction.EXECUTE_ERROR }, this.errorSerializer.serialize(error, {\r\n                            errorCode: WorkerRunnerErrorCode.RUNNER_EXECUTE_ERROR,\r\n                            name: RunnerExecuteError.name,\r\n                            message: WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR({ runnerName: this.runnerName }),\r\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                        })));\r\n                    }\r\n                    break;\r\n                case RunnerControllerAction.DESTROY:\r\n                    try {\r\n                        yield this.destroy(port, action);\r\n                    }\r\n                    catch (error) {\r\n                        this.sendAction(port, Object.assign({ id: action.id, type: RunnerEnvironmentAction.DESTROY_ERROR }, this.errorSerializer.serialize(error, {\r\n                            errorCode: WorkerRunnerErrorCode.RUNNER_DESTROY_ERROR,\r\n                            name: RunnerDestroyError.name,\r\n                            message: WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR({ runnerName: this.runnerName }),\r\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                        })));\r\n                    }\r\n                    break;\r\n                case RunnerControllerAction.RESOLVE:\r\n                    yield this.resolve(port, action);\r\n                    break;\r\n                case RunnerControllerAction.DISCONNECT:\r\n                    yield this.disconnect(port, action);\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    execute(port, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let response;\r\n            const deserializeArgumentsData = this.workerRunnerResolver.deserializeArguments(action.args);\r\n            try {\r\n                response = this.runnerInstance[action.method](...deserializeArgumentsData.args);\r\n            }\r\n            catch (error) {\r\n                this.sendAction(port, Object.assign({ id: action.id, type: RunnerEnvironmentAction.EXECUTE_ERROR }, this.errorSerializer.serialize(error, {\r\n                    errorCode: WorkerRunnerErrorCode.RUNNER_EXECUTE_ERROR,\r\n                    message: WORKER_RUNNER_ERROR_MESSAGES.EXECUTE_ERROR({\r\n                        runnerName: this.runnerName,\r\n                        methodName: action.method,\r\n                    }),\r\n                    name: RunnerExecuteError.name,\r\n                    stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                })));\r\n                yield Promise.all(deserializeArgumentsData.controllers\r\n                    .map(controller => controller.disconnect()));\r\n                return;\r\n            }\r\n            if (response instanceof Promise) {\r\n                try {\r\n                    yield this.handleExecuteResponse(port, action, yield response);\r\n                }\r\n                catch (error) {\r\n                    this.sendAction(port, Object.assign({ id: action.id, type: RunnerEnvironmentAction.EXECUTE_ERROR }, this.errorSerializer.serialize(error, {\r\n                        errorCode: WorkerRunnerErrorCode.RUNNER_EXECUTE_ERROR,\r\n                        message: WORKER_RUNNER_ERROR_MESSAGES.EXECUTE_ERROR({\r\n                            runnerName: this.runnerName,\r\n                            methodName: action.method,\r\n                        }),\r\n                        name: RunnerExecuteError.name,\r\n                        stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                    })));\r\n                    yield Promise.all(deserializeArgumentsData.controllers\r\n                        .map(controller => controller.disconnect()));\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                yield this.handleExecuteResponse(port, action, response);\r\n            }\r\n            this.addConnectedControllers(deserializeArgumentsData.controllers);\r\n        });\r\n    }\r\n    addConnectedControllers(controllers) {\r\n        this.connectedControllers.push(...controllers);\r\n    }\r\n    disconnect(port, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const portIndex = this.ports.indexOf(port);\r\n            this.ports.splice(portIndex, 1);\r\n            if (this.ports.length === 0) {\r\n                yield this.destroy();\r\n            }\r\n            this.sendAction(port, {\r\n                type: RunnerEnvironmentAction.DISCONNECTED,\r\n                id: action.id,\r\n            });\r\n            port.onmessage = null;\r\n            port.close();\r\n        });\r\n    }\r\n    handleExecuteResponse(port, action, responseWithTransferData, transferable = []) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let response;\r\n            if (responseWithTransferData instanceof TransferRunnerData) {\r\n                transferable.push(...responseWithTransferData.transfer);\r\n                response = responseWithTransferData.data;\r\n            }\r\n            else {\r\n                response = responseWithTransferData;\r\n            }\r\n            if (RunnerBridge.isRunnerBridge(response)) {\r\n                const runnerController = yield response[RUNNER_BRIDGE_CONTROLLER];\r\n                const transferPort = yield runnerController.resolveOrTransferControl();\r\n                this.sendAction(port, {\r\n                    type: RunnerEnvironmentAction.EXECUTED_WITH_RUNNER_RESULT,\r\n                    id: action.id,\r\n                    port: transferPort,\r\n                    runnerId: runnerController.runnerId,\r\n                }, [transferPort, ...transferable]);\r\n            }\r\n            else {\r\n                this.sendAction(port, {\r\n                    type: RunnerEnvironmentAction.EXECUTED,\r\n                    id: action.id,\r\n                    response: response,\r\n                }, transferable);\r\n            }\r\n        });\r\n    }\r\n    notifyControllersAboutDestruction() {\r\n        for (const port of this.ports) {\r\n            this.sendAction(port, {\r\n                type: RunnerEnvironmentAction.DESTROYED,\r\n                id: -1,\r\n            });\r\n            port.onmessage = null;\r\n            port.close();\r\n        }\r\n        this.ports = [];\r\n    }\r\n    destroy(port, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let destroyError;\r\n            if (this.runnerInstance.destroy) {\r\n                let response;\r\n                try {\r\n                    response = this.runnerInstance.destroy();\r\n                }\r\n                catch (error) {\r\n                    if (action && port) {\r\n                        destroyError = Object.assign({ id: action.id, type: RunnerEnvironmentAction.DESTROY_ERROR }, this.errorSerializer.serialize(error, {\r\n                            errorCode: WorkerRunnerErrorCode.RUNNER_DESTROY_ERROR,\r\n                            message: WORKER_RUNNER_ERROR_MESSAGES.EXECUTE_ERROR({\r\n                                runnerName: this.runnerName,\r\n                                methodName: 'destroy',\r\n                            }),\r\n                            name: RunnerExecuteError.name,\r\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                        }));\r\n                    }\r\n                }\r\n                if (response instanceof Promise) {\r\n                    try {\r\n                        yield response;\r\n                    }\r\n                    catch (error) {\r\n                        if (action && port) {\r\n                            destroyError = Object.assign({ id: action.id, type: RunnerEnvironmentAction.DESTROY_ERROR }, this.errorSerializer.serialize(error, {\r\n                                errorCode: WorkerRunnerErrorCode.RUNNER_DESTROY_ERROR,\r\n                                message: WORKER_RUNNER_ERROR_MESSAGES.EXECUTE_ERROR({\r\n                                    runnerName: this.runnerName,\r\n                                    methodName: 'destroy',\r\n                                }),\r\n                                name: RunnerExecuteError.name,\r\n                                stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                            }));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (port) {\r\n                const portIndex = this.ports.indexOf(port);\r\n                this.ports.splice(portIndex, 1);\r\n                port.onmessage = null;\r\n                this.notifyControllersAboutDestruction();\r\n                if (action) {\r\n                    this.sendAction(port, destroyError || {\r\n                        id: action.id,\r\n                        type: RunnerEnvironmentAction.DESTROYED,\r\n                    });\r\n                }\r\n                port.close();\r\n            }\r\n            else {\r\n                this.notifyControllersAboutDestruction();\r\n            }\r\n            this.onDestroyed();\r\n        });\r\n    }\r\n    resolve(port, action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const messageChanel = new MessageChannel();\r\n            messageChanel.port1.onmessage = this.onPortMessage.bind(this, messageChanel.port1);\r\n            this.ports.push(messageChanel.port1);\r\n            this.sendAction(port, {\r\n                type: RunnerEnvironmentAction.RESOLVED,\r\n                id: action.id,\r\n                port: messageChanel.port2,\r\n            }, [messageChanel.port2]);\r\n        });\r\n    }\r\n    sendAction(port, action, transfer) {\r\n        port.postMessage(action, transfer);\r\n    }\r\n}\n\nclass WorkerRunnerResolverBase {\r\n    constructor(config) {\r\n        this.runnerEnvironments = new Set();\r\n        this.runnerBridgeConstructors = new Array();\r\n        this.RunnerEnvironmentConstructor = RunnerEnvironment;\r\n        this.errorSerializer = WORKER_RUNNER_ERROR_SERIALIZER;\r\n        this.RunnerControllerConstructor = RunnerController;\r\n        this.runners = config.runners;\r\n        this.runnerBridgeConstructors = this.runners.map(runner => resolveRunnerBridgeConstructor(runner));\r\n    }\r\n    run() {\r\n        self.addEventListener('message', this.onMessage.bind(this));\r\n        this.sendAction({ type: WorkerResolverAction.WORKER_INITED });\r\n    }\r\n    onMessage(message) {\r\n        this.handleAction(message.data);\r\n    }\r\n    handleAction(action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            switch (action.type) {\r\n                case NodeResolverAction.INIT_RUNNER:\r\n                    try {\r\n                        yield this.initRunnerInstance(action);\r\n                    }\r\n                    catch (error) {\r\n                        this.sendAction(Object.assign({ id: action.id, type: WorkerResolverAction.RUNNER_INIT_ERROR }, this.errorSerializer.serialize(error, {\r\n                            errorCode: WorkerRunnerErrorCode.RUNNER_INIT_ERROR,\r\n                            name: RunnerInitError.name,\r\n                            message: WORKER_RUNNER_ERROR_MESSAGES.UNEXPECTED_ERROR(),\r\n                            stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                        })));\r\n                    }\r\n                    break;\r\n                case NodeResolverAction.DESTROY:\r\n                    try {\r\n                        yield this.destroyWorker(action.force);\r\n                    }\r\n                    catch (error) {\r\n                        this.sendAction({ type: WorkerResolverAction.DESTROYED });\r\n                    }\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n    initRunnerInstance(action) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const runnerConstructor = this.runners[action.runnerId];\r\n            if (runnerConstructor) {\r\n                const messageChanel = new MessageChannel();\r\n                const deserializeArgumentsData = this.deserializeArguments(action.args);\r\n                let runner;\r\n                try {\r\n                    runner = new runnerConstructor(...deserializeArgumentsData.args);\r\n                }\r\n                catch (error) {\r\n                    this.sendAction(Object.assign({ id: action.id, type: WorkerResolverAction.RUNNER_INIT_ERROR }, this.errorSerializer.serialize(error, {\r\n                        errorCode: WorkerRunnerErrorCode.RUNNER_INIT_ERROR,\r\n                        message: WORKER_RUNNER_ERROR_MESSAGES.RUNNER_INIT_ERROR({\r\n                            runnerName: runnerConstructor.name,\r\n                        }),\r\n                        name: RunnerInitError.name,\r\n                        stack: (error === null || error === void 0 ? void 0 : error.stack) || new Error().stack,\r\n                    })));\r\n                    yield Promise.all(deserializeArgumentsData.controllers\r\n                        .map(controller => controller.disconnect()));\r\n                    return;\r\n                }\r\n                const runnerEnvironment = new this.RunnerEnvironmentConstructor({\r\n                    port: messageChanel.port1,\r\n                    runner,\r\n                    workerRunnerResolver: this,\r\n                    onDestroyed: () => this.runnerEnvironments.delete(runnerEnvironment),\r\n                });\r\n                this.runnerEnvironments.add(runnerEnvironment);\r\n                runnerEnvironment.addConnectedControllers(deserializeArgumentsData.controllers);\r\n                this.sendAction({\r\n                    type: WorkerResolverAction.RUNNER_INITED,\r\n                    id: action.id,\r\n                    port: messageChanel.port2,\r\n                }, [messageChanel.port2]);\r\n            }\r\n            else {\r\n                throw new RunnerInitError();\r\n            }\r\n        });\r\n    }\r\n    deserializeArguments(args) {\r\n        const result = {\r\n            args: new Array(),\r\n            controllers: new Array(),\r\n        };\r\n        for (const argument of args) {\r\n            switch (argument.type) {\r\n                case RunnerArgumentType.RUNNER_INSTANCE:\r\n                    const controller = new this.RunnerControllerConstructor({\r\n                        runnerId: argument.runnerId,\r\n                        runnerBridgeConstructors: this.runnerBridgeConstructors,\r\n                        port: argument.port,\r\n                        runners: this.runners,\r\n                    });\r\n                    result.controllers.push(controller);\r\n                    result.args.push(controller.resolvedRunner);\r\n                    break;\r\n                default:\r\n                    result.args.push(argument.data);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    destroyWorker(force = false) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!force) {\r\n                const destroying$ = new Array();\r\n                this.runnerEnvironments.forEach((runnerEnvironment) => {\r\n                    destroying$.push(runnerEnvironment.destroy());\r\n                });\r\n                yield Promise.all(destroying$);\r\n            }\r\n            this.runnerEnvironments.clear();\r\n            this.sendAction({ type: WorkerResolverAction.DESTROYED });\r\n        });\r\n    }\r\n    sendAction(action, transfer) {\r\n        // @ts-ignore\r\n        postMessage(action, transfer);\r\n    }\r\n    wrapRunner(runner) {\r\n        const messageChanel = new MessageChannel();\r\n        const runnerEnvironment = new this.RunnerEnvironmentConstructor({\r\n            port: messageChanel.port1,\r\n            runner,\r\n            workerRunnerResolver: this,\r\n            onDestroyed: () => this.runnerEnvironments.delete(runnerEnvironment),\r\n        });\r\n        this.runnerEnvironments.add(runnerEnvironment);\r\n        return messageChanel.port2;\r\n    }\r\n}\n\nexport { CODE_TO_ERROR_MAP, NodeAndLocalRunnerResolverBase, NodeResolverAction, NodeRunnerResolverBase, RUNNER_BRIDGE_CONTROLLER, RunnerBridge, RunnerController, RunnerControllerAction, RunnerDestroyError, RunnerEnvironment, RunnerEnvironmentAction, RunnerExecuteError, RunnerInitError, RunnerWasDisconnectedError, TransferRunnerData, WORKER_RUNNER_ERROR_CODE, WORKER_RUNNER_ERROR_MESSAGES, WorkerNotInitError, WorkerResolverAction, WorkerRunnerError, WorkerRunnerErrorCode, WorkerRunnerErrorSerializer, WorkerRunnerResolverBase };\n//# sourceMappingURL=core.js.map\n","import { NodeAndLocalRunnerResolverBase, WorkerRunnerResolverBase } from '@worker-runner/core';\n\nclass NodeRunnerResolver extends NodeAndLocalRunnerResolverBase {\r\n}\n\nclass WorkerRunnerResolver extends WorkerRunnerResolverBase {\r\n}\n\nclass LocalRunnerResolver extends NodeRunnerResolver {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.WorkerResolverConstructor = WorkerRunnerResolver;\r\n    }\r\n}\n\nclass RunnerResolver extends NodeRunnerResolver {\r\n    constructor(config) {\r\n        super(config);\r\n        this.workerRunnerResolver = new WorkerRunnerResolver(config);\r\n    }\r\n    runInWorker() {\r\n        this.workerRunnerResolver.run();\r\n    }\r\n}\n\nexport { LocalRunnerResolver, NodeRunnerResolver, RunnerResolver, WorkerRunnerResolver };\n//# sourceMappingURL=promise.js.map\n","import { RunnerResolver } from \"@worker-runner/promise\";\r\nimport { LibraryRunner } from \"./library-runner\";\r\n\r\nexport const runnerResolver = new RunnerResolver({\r\n    runners: [LibraryRunner],\r\n    workerPath: 'worker-injector.js',\r\n});\r\n","const WORKER_LOG_STYLE = 'background-color: #FFCC33; padding: 4px; border-radius: 3px; color: black;';\r\nconst BOOK_LOG_STYLE = 'font-weight: bold;';\r\nconst SECONDS_LOG_STYLE = BOOK_LOG_STYLE;\r\n\r\nexport class LibraryRunner {\r\n    private books: string[]\r\n    constructor (books: string[] = []) {\r\n        this.books = books;\r\n    }\r\n\r\n    public addBook(book: string): void {\r\n        this.books.push(book);\r\n        console.log(\r\n            `%cWorker:%c Book %c\"${book}\"%c added to library`,\r\n            WORKER_LOG_STYLE, '', BOOK_LOG_STYLE, '',\r\n        );\r\n    }\r\n\r\n    public checkBook(book: string): boolean {\r\n        const isExist = this.books.indexOf(book) !== -1;\r\n        console.log(\r\n            `%cWorker:%c Book %c\"${book}\"%c is exist in the library: `,\r\n            WORKER_LOG_STYLE, '', BOOK_LOG_STYLE, '', isExist,\r\n        );\r\n        return isExist;\r\n    }\r\n\r\n    public async reserveBook(book: string, seconds: number): Promise<string> {\r\n        console.log(\r\n            `%cWorker:%c Book %c\"${book}\"%c reserved for %c${seconds}%c seconds`,\r\n            WORKER_LOG_STYLE, '', BOOK_LOG_STYLE, '', SECONDS_LOG_STYLE, '',\r\n        );\r\n\r\n        this.books = this.books.filter(libraryBook => libraryBook !== book);\r\n\r\n        await new Promise(resolve => setTimeout(() => resolve(), seconds * 1000));\r\n        this.books.push(book);\r\n\r\n        console.log(\r\n            `%cWorker:%c Reservation for book %c\"${book}\"%c completed after %c${seconds}%c seconds`,\r\n            WORKER_LOG_STYLE, '', BOOK_LOG_STYLE, '', SECONDS_LOG_STYLE, '',\r\n        );\r\n        return book;\r\n    }\r\n}\r\n"],"sourceRoot":""}